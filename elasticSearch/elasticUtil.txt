No entanto, Elasticsearch é muito mais do que apenas Lucene e muito mais do que “apenas” pesquisa de texto completo. Também pode ser descrito da seguinte forma:

- Um armazenamento de documentos em tempo real distribuído onde cada campo é indexado e pesquisável

- Um mecanismo de pesquisa distribuído com análises em tempo real

- Capaz de escalar para centenas de servidores e petabytes de dados estruturados e não estruturados


Elasticsearch é orientado a documentos , o que significaque armazena objetos ou documentos inteiros. Ele não apenas os armazena, mas também indexa o conteúdo de cada documento para torná-los pesquisáveis.


--Métodos simples de consulta:

Para fazer isso, usaremos um método de pesquisa leve que é fácil de usar na linha de comando. Este método é frequentemente referido comouma pesquisa de string de consulta , já que passamos a pesquisa como um parâmetro de string de consulta de URL:

GET /megacorp/employee/_search?q=last_name:Smith

Elasticsearch fornece uma linguagem de consulta rica e flexível chamada DSL de consulta , que nos permite construir consultas muito mais complexas e robustas.

--Consulta com dsl

O idioma específico do domínio (DSL) éespecificado usando um corpo de solicitação JSON. Podemos representar a pesquisa anterior para todos os Smiths da seguinte forma:

GET /megacorp/employee/_search
{
    "query" : {
        "match" : {
            "last_name" : "Smith"
        }
    }
}

-- Subir elastic no docker --

docker run -p 9200:9200 -p 9300:9300 -e "discovery.type=single-node" docker.elastic.co/elasticsearch/elasticsearch:6.8.19

----

Vamos complicar um pouco a pesquisa. Ainda queremos encontrar todos os funcionários com o sobrenome Smith, mas queremos apenas funcionários com mais de 30 anos.
Nossa consulta mudará um pouco para acomodar um filtro , que nos permite executar pesquisas estruturadas com eficiência:

{
    "query" : {
        "filtered" : {
            "filter" : {
                "range" : {
                    "age" : { "gt" : 30 } 1
                }
            },
            "query" : {
                "match" : {
                    "last_name" : "smith" 2
                }
            }
        }
    }
}

 -- Match trata parecido por exemplo buscar que gosta de escalada:

{
"query" : {
        "match" : {
            "about" : "rock climbing"
        }
    }
}

Irá retornar quem curte rock tbm... para contornarmos isso é preciso buscar a palavra igual por meio do:

"match_phrase" : {
            "about" : "rock climbing"
        }


-- Destacando nossas pesquisas --



{
  "query" : {
    "match_phrase" : {
      "about" : "rock climbing"
    }
  },
  "highlight": {
    "fields" : {
      "about" : {}
    }
  }
}

Dessa forma vai trazer o le contém um trecho de texto do aboutcampo com as palavras correspondentes embrulhadas em <em></em> tags HTML.

--Analytics

Elasticsearch tem uma funcionalidade chamada agregações , quepermitem que você gere análises sofisticadas sobre seus dados.
É semelhante ao GROUP BY SQL, mas muito mais poderoso.



Essas agregações não são pré-calculadas; eles são gerados instantaneamente a partir dos documentos que correspondem à consulta atual


--Natureza distribuida

Embora nosso tutorial tenha dado exemplos de como usar o Elasticsearch, ele não tocou na mecânica.
Elasticsearch é distribuído por natureza e foi projetado para ocultar a complexidade que vem com a distribuição.

Elasticsearch se esforça para esconder a complexidade dos sistemas distribuídos.
Aqui estão algumas das operações que acontecem automaticamente nos bastidores:

Capítulo 3. Entrada de Dados, Saída de Dados

Elasticsearch é um armazenamento de documentos distribuído .Ele pode armazenar e recuperar estruturas de dados complexas - serializadas como documentos JSON - em tempo real .
Em outras palavras, assim que um documento é armazenado no Elasticsearch, ele pode ser recuperado de qualquer nó do cluster.

No Elasticsearch, todos os dados em cada campo são indexados por padrão .Ou seja, cada campo tem um índice invertido dedicado para recuperação rápida.

Um documento não consiste apenas em seus dados.Ele também tem metadados -informações sobre o documento.
Os três elementos de metadados necessários são os seguintes:

_index
Onde o documento mora

_type
A classe de objeto que o documento representa

_id
O identificador único do documento

Nome do índice: Este nome deve estar em minúsculas, não pode começar com sublinhado e não pode conter vírgulas.
Vamos usar websitecomo nosso nome de índice.

Por exemplo, se nosso índice for chamado website, nosso tipo for chamado bloge escolhermos o ID 123, a solicitação de índice terá a seguinte aparência:

PUT /website/blog/123
{
  "title": "My first blog entry",
  "text":  "Just trying this out...",
  "date":  "2014/01/01"
}


IDs de geração automática
Se nossos dados não tiverem um ID natural, podemos deixar o Elasticsearch gerar um para nós automaticamente. A estrutura da solicitação muda:
em vez de usar o PUT verbo ( “guardar este documento nesta URL”), usamos o POSTverbo ( “guardar este documento sob este URL”).

Exemplo:

POST /website/blog/
{
  "title": "My second blog entry",
  "text":  "Still trying this out...",
  "date":  "2014/01/01"
}

Recuperando um Documento:

GET / site / blog / 123? pretty

Adicionando prettyaos parâmetros de string de consulta para qualquer solicitação,
como no exemplo anterior, faz com que Elasticsearch imprima bem oResposta JSON para torná-lo mais legível.

Recuperando Parte de um Documento:

Ou se quiser apenas o _sourcecampo sem metadados, você pode usar o _sourceendpoint.

GET / website / blog / 123 / _source

Verificar se existe um documento

Se tudo o que você deseja fazer é verificar se um documento existe...

curl -i -XHEAD http://localhost:9200/website/blog/123

retorna um 200 se assim o doc existir, se não existir retorna

---------------Atualizando um documento inteiro---------------

Os documentos no Elasticsearch são imutáveis ; não podemos mudá-los.Em vez disso, se precisarmos atualizar um documento existente,
nós o reindexamos ou substituímos,que podemos fazer usando a mesma index.

Exemplo atualização

PUT /website/blog/123
{
  "title": "My first blog entry",
  "text":  "I am starting to get the hang of this...",
  "date":  "2014/01/02"
}


Internamente, o Elasticsearch marcou o documento antigo como excluído e adicionou um documento inteiramente novo.
A versão antiga do documento não desaparece imediatamente, embora você não consiga acessá-la.
O Elasticsearch limpa os documentos excluídos em segundo plano à medida que você continua a indexar mais dados.

---------------Criando um Novo Documento---------------

No entanto, se já temos um _idque queremos usar, então temos de dizer ElasticSearch que ele deve aceitar o nosso pedido índice apenas se um documento com o mesmo _index, _typee _idainda não existir.

Exemplo de chamada:

PUT /website/blog/123?op_type=create
{ ... }

OU

PUT /website/blog/123/_create
{ ... }

Caso existir retorna um 409

{
  "error" : "DocumentAlreadyExistsException[[website][4] [blog][123]:
             document already exists]",
  "status" : 409
}

------------Atualizações parciais de documentos------

O updateAPI deve obedecer às mesmas regras. Externamente, parece que estamos atualizando parcialmente um documento no local.
Internamente, no entanto, a updateAPI simplesmente gerencia o mesmo processo de recuperação-alteração-reindexação que já descrevemos.

A forma mais simples da updatesolicitação aceita um documento parcial como docparâmetro, que apenas é mesclado com o documento existente.

Exemplo:

POST /website/blog/1/_update
{
   "doc" : {
      "tags" : [ "testing" ],
      "views": 0
   }
}

---------------Usando scripts para fazer atualizações parciais---------------

Para aqueles momentos em que a API não é suficiente, o Elasticsearch permite que você escreva sua própria lógica personalizada em um script.
O script é compatível com muitas APIs, incluindo pesquisa, classificação, agregações e atualizações de documentos.
Os scripts podem ser passados como parte da solicitação, recuperados do .scripts índice especial ou carregados do disco.
A linguagem de script padrão é Groovy.


---------------Excluindo um Documento---------------

A sintaxe para excluir um documento segue o mesmo padrão que já vimos, mas usa o DELETE método:

DELETE /website/blog/123

-----Recuperando vários documentos-----
Por mais rápido que o Elasticsearch seja, ele pode ser ainda mais rápido.Combinar várias solicitações em uma evita a sobrecarga da rede de processar cada solicitação individualmente.
Se você sabe que precisa recuperar vários documentos do Elasticsearch,
é mais rápido recuperá-los todos em uma única solicitação usando o multi-get , ou mgetAPI, em vez de documento por documento.

A mgetAPI espera uma docsmatriz, cadaelemento que especifica o _index... Exemplo:

GET /_mget
{
   "docs" : [
      {
         "_index" : "website",
         "_type" :  "blog",
         "_id" :    2
      },
      {
         "_index" : "website",
         "_type" :  "pageviews",
         "_id" :    1,
         "_source": "views"
      }
   ]
}

O corpo da resposta também contém uma docsmatrizque contém uma resposta por documento...

{
   "docs" : [
      {
         "_index" :   "website",
         "_id" :      "2",
         "_type" :    "blog",
         "found" :    true,
         "_source" : {
            "text" :  "This is a piece of cake...",
            "title" : "My first external blog entry"
         },
         "_version" : 10
      },
      {
         "_index" :   "website",
         "_id" :      "1",
         "_type" :    "pageviews",
         "found" :    true,
         "_version" : 2,
         "_source" : {
            "views" : 2
         }
      }
   ]
}




---Lidando com Conflitos---

Ao atualizar um documento com a indexAPI,
lemos o documento original, fazemos nossas alterações e, em seguida, reindexamos todo o documento de uma vez.


No mundo do banco de dados, duas abordagens são comumente usadas para garantir que as mudanças não sejam perdidas ao fazer atualizações simultâneas:

Controle de concorrência pessimista
Amplamente usado por bancos de dados relacionais, essa abordagem pressupõe que mudanças conflitantes podem acontecer e,
portanto, bloqueia o acesso a um recurso para evitar conflitos.
Um exemplo típico é bloquear uma linha antes de ler seus dados, garantindo que apenas o encadeamento que colocou o bloqueio seja capaz de fazer alterações nos dados dessa linha.

Controle de concorrência otimista
Usado por Elasticsearch, essa abordagem pressupõe que é improvável que os conflitos ocorram e não impede que as operações sejam tentadas.
No entanto, se os dados subjacentes foram modificados entre a leitura e a gravação, a atualização falhará. Cabe então ao aplicativo decidir como deve resolver o conflito.
Por exemplo, ele pode tentar novamente a atualização, usando os dados novos, ou pode relatar a situação ao usuário.


Um _version número que é incrementado sempre que um documento é alterado.
Elasticsearch usa esse _versionnúmero para garantir que as alterações sejam aplicadas na ordem correta.
Se uma versão mais antiga de um documento chegar após uma nova versão, ela pode ser simplesmente ignorada.

---Controle de simultaneidade otimista*--


Vamos criar uma nova postagem no blog:

PUT /website/blog/1/_create
{
  "title": "My first blog entry",
  "text":  "Just trying this out..."
}

O corpo da resposta nos diz que este documento recém-criado possui _version número 1.

Agora, quando tentamos salvar nossas alterações reindexando o documento, especificamos o versionao qual nossas alterações devem ser aplicadas:


PUT /website/blog/1?version=1 1
{
  "title": "My first blog entry",
  "text":  "Starting to get the hang of this..."
}

Essa solicitação é bem-sucedida e o corpo da resposta nos diz que o _version foi incrementado para 2...


No entanto, se tivéssemos de executar novamente a mesma solicitação de índice, ainda especificando version=1, Elasticsearch responderia com um 409 Conflictcódigo de resposta HTTP.

Isso nos diz que o _version número atual do documento no Elasticsearch é 2, mas que especificamos que estávamos atualizando a versão 1.

Todas as APIs que atualizam ou excluem um documento aceitam um version parâmetro, o que permite que você aplique o controle de simultaneidade otimista apenas às partes do seu código onde faz sentido.


--------Usando versões de um sistema externo-----

Se seu banco de dados principal já tiver números de versão - ou um valor como timestampesse pode ser usado como um número de versão - você pode reutilizar esses mesmos números de versão no Elasticsearch adicionando version_type=externalà string de consulta.
Os números da versão devem ser inteiros maiores que zero e menores que cerca de 9.2e+18- um longvalor positivo em Java.

Como o elastic verifica:

Em vez de verificar se o atual _versioné o mesmo especificado na solicitação, o Elasticsearch verifica se o atual _versioné menor que a versão especificada.

**Os números de versão externa podem ser especificados não apenas nas solicitações de indexação e exclusão, mas também na criação de novos documentos.

Exemplo de criação com external:

PUT /website/blog/2?version=5&version_type=external
{
  "title": "My first external blog entry",
  "text":  "Starting to get the hang of this..."
}

Agora, atualizamos este documento, especificando um novo versionnúmero de 10:

PUT /website/blog/2?version=10&version_type=external
{
  "title": "My first external blog entry",
  "text":  "This is a piece of cake..."
}
**Se você executasse novamente esta solicitação, ela falharia com o mesmo erro de conflito que vimos antes, porque o número da versão externa especificada não é maior do que a versão atual no Elasticsearch.
Dessa forma vai atualizando de acordo com o que é passado na version external.

---Atualizações parciais de documentos

Também dissemos que os documentos são imutáveis: não podem ser alterados, apenas substituídos. A updateAPI deve obedecer às mesmas regras.
Externamente, parece que estamos atualizando parcialmente um documento no local.
Internamente, no entanto, a updateAPI simplesmente gerencia o mesmo processo de recuperação-alteração-reindexação que já descrevemos

A forma mais simples da update solicitação aceita um documento parcial como docparâmetro, que apenas é mesclado com o documento existente.

Por exemplo, poderíamos adicionar um tagscampo e um viewscampo à postagem do nosso blog da seguinte maneira:

POST /website/blog/1/_update
{
   "doc" : {
      "tags" : [ "testing" ],
      "views": 0
   }
}

------Recuperando vários documentos


A mgetAPI espera uma docsmatriz, cadaelemento que especifica o _index, _typee _id metadados do documento que você deseja recuperar.
Você também pode especificar um _source parâmetro se quiser apenas recuperar um ou mais campos específicos:

GET /_mget
{
   "docs" : [
      {
         "_index" : "website",
         "_type" :  "blog",
         "_id" :    2
      },
      {
         "_index" : "website",
         "_type" :  "pageviews",
         "_id" :    1,
         "_source": "views"
      }
   ]
}

O corpo da resposta também contém uma docs matriz que contém uma resposta por documento, na mesma ordem especificada na solicitação,
resposta que esperaríamos de uma get solicitação individual...

Exemplo chamada com vários documentos:

Na verdade, se todos os documentos tiverem o mesmo _indexe _type, você poderá simplesmente passar uma matriz de em idsvez da docsmatriz completa :

GET /website/blog/_mget
{
   "ids" : [ "2", "1" ]
}

Observe que o segundo documento que solicitamos não existe.
Especificamos o tipo blog, mas o documento com ID 1é do tipo pageviews. Essa inexistência é relatada no corpo da resposta:


{
  "docs" : [
    {
      "_index" :   "website",
      "_type" :    "blog",
      "_id" :      "2",
      "_version" : 10,
      "found" :    true,
      "_source" : {
        "title":   "My first external blog entry",
        "text":    "This is a piece of cake..."
      }
    },
    {
      "_index" :   "website",
      "_type" :    "blog",
      "_id" :      "1",
      "found" :    false  1
    }
  ]
}

O código de status HTTP para a solicitação anterior é 200, embora um documento não tenha sido encontrado.
Na verdade, ainda seria 200 se nenhum dos documentos solicitados fosse encontrado -  porque a mget própria solicitação foi concluída com êxito.
Para determinar o sucesso ou falha dos documentos individuais, você precisa verificara found bandeira.





